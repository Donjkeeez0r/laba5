'''
Задана рекуррентная функция. Область определения функции – натуральные числа.
Написать программу сравнительного вычисления данной функции рекурсивно и итерационно (значение, время). Определить (смоделировать) границы применимости рекурсивного и итерационного подхода.
Результаты сравнительного исследования времени вычисления представить в табличной и графической форме в виде отчета по лабораторной работе.

2.	F(1) = 1; G(1) = 1; F(n) = (-1)n*(F(n–1) – 2*G(n–1)), G(n) = F(n–1) /(2n)! + G(n–1), при n >=2
'''

import timeit
import matplotlib.pyplot as plt

# Функция для вычисления факториала
def calculate_factorial(num):
    result = 1
    for i in range(2, num + 1):
        result *= i
    return result

# Рекурсивная функция для F
def recursive_F(n):
    if n == 1:
        return 1
    else:
        return (-1)**n * (recursive_F(n-1) - 2 * recursive_G(n-1))

# Рекурсивная функция для G
def recursive_G(n):
    if n == 1:
        return 1
    else:
        return recursive_F(n-1) / calculate_factorial(2*n) + recursive_G(n-1)

# Итеративная функция для F
def iterative_F(n):
    if n == 1:
        return 1
    F_prev = 1
    G_prev = 1
    for i in range(2, n + 1):
        F_current = (-1)**i * (F_prev - 2 * G_prev)
        F_prev = F_current
        G_prev = iterative_G(i - 1)
    return F_current

# Итеративная функция для G
def iterative_G(n):
    if n == 1:
        return 1
    F_prev = 1
    G_prev = 1
    for i in range(2, n + 1):
        F_current = (-1)**i * (F_prev - 2 * G_prev)
        G_current = F_prev / calculate_factorial(2 * i) + G_prev
        F_prev = F_current
        G_prev = G_current
    return G_current


n_values = range(2, 11)

recursive_times = []
iterative_times = []

for n in n_values:
    time_recursive = timeit.timeit(lambda: recursive_F(n), number=1) # Измерение времени выполнения рекурсивной функции
    recursive_times.append(time_recursive)

    time_iterative = timeit.timeit(lambda: iterative_F(n), number=1) # Измерение времени выполнения итеративной функции
    iterative_times.append(time_iterative)

# Вывод результатов времени выполнения
print("n\t| Рекурсивное время (сек)\t| Итеративное время (сек)")
print("-" * 50)

for i, n in enumerate(n_values):
    print(f"{n}\t| {recursive_times[i]:.6f}\t\t\t| {iterative_times[i]:.6f}")

# Визуализация времени выполнения
plt.figure(figsize=(12, 6))
plt.plot(n_values, recursive_times, label='Рекурсивное время (сек)', marker='o')
plt.plot(n_values, iterative_times, label='Итеративное время (сек)', marker='x')
plt.xlabel('n')
plt.ylabel('Время (сек)')
plt.title('Сравнение времени выполнения рекурсивной и итеративной функций')
plt.legend()
plt.grid(True)
plt.show()



