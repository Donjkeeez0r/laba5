'''
Задана рекуррентная функция. Область определения функции – натуральные числа.
Написать программу сравнительного вычисления данной функции рекурсивно и итерационно (значение, время). Определить (смоделировать) границы применимости рекурсивного и итерационного подхода.
Результаты сравнительного исследования времени вычисления представить в табличной и графической форме в виде отчета по лабораторной работе.
2.	F(1) = 1; G(1) = 1; F(n) = (-1)n*(F(n–1) – 2*G(n–1)), G(n) = F(n–1) /(2n)! + G(n–1), при n >=2
'''

import timeit
import matplotlib.pyplot as plt

# Кэш для хранения вычисленных значений факториалов
factorial_cache = {0: 1, 1: 1}
last_factorial = 1

# Функция для вычисления факториала числа
def dynamic_factorial(n):
    global last_factorial
    if n in factorial_cache:
        last_factorial = n * factorial_cache[n]
    else:
        last_factorial = n * last_factorial
    return last_factorial

# Рекурсивная функция для вычисления факториала
def recursive_factorial(n):
    if n == 1:
        return 1
    else:
        return n * recursive_factorial(n-1)

# Итеративная функция для вычисления факториала
def iterative_factorial(n):
    result = 1
    for i in range(2, n+1):
        result *= i
    return result

# Функция для вычисления значения G
def dynamic_G(n, cache={1: 1}, step=1):
    if n in cache:
        return cache[n]
    else:
        result = dynamic_F(n-1, cache, -step) / (dynamic_factorial(2*n) + dynamic_G(n-1, cache, -step))
        cache[n] = result
        return result

# Функция для вычисления значения F
def dynamic_F(n, cache={1: 1}, step=1):
    if n in cache:
        return cache[n]
    else:
        result = step * ((dynamic_F(n-1, cache, -step) - 2 * dynamic_G(n-1, cache, -step)))
        cache[n] = result
        return result

# Функция для записи времени
def score_time(func, n):
    return timeit.timeit(lambda: func(n), number=1000)

# Значения n для которых мы хотим измерить время выполнения
n_values = range(2, 11)
recursive_times = []
iterative_times = []
dynamic_times = []

# Измерение времени выполнения для каждого значения n
for n in n_values:
    recursive_times.append(score_time(recursive_factorial, n))
    iterative_times.append(score_time(iterative_factorial, n))
    dynamic_times.append(score_time(dynamic_F, n))
    dynamic_times.append(score_time(dynamic_G, n))

# Вывод результатов в табличной форме
print(f"{'n':<10}{'Рекурсивное время (мс)':<25}{'Итерационное время (мс)':<25}{'Динамическое время (мс)':<25}")
for i, n in enumerate(n_values):
    print(f"{n:<10}{recursive_times[i]:<25}{iterative_times[i]:<25}{dynamic_times[i]:<25}")

# Построение и вывод графика результатов
plt.plot(n_values, recursive_times, label='Рекурсивно')
plt.plot(n_values, iterative_times, label='Итерационно')
plt.plot(n_values, dynamic_times[::2], label='Динамическое')  # Используем только четные индексы для значений F(n)
plt.xlabel('n')
plt.ylabel('Время (в миллисекундах)')
plt.legend()
plt.title('Сравнение времени вычисления функции F(n)')
plt.show()
